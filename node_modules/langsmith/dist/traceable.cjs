"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapFunctionAndEnsureTraceable = exports.isTraceableFunction = exports.getCurrentRunTree = exports.traceable = void 0;
const async_hooks_1 = require("async_hooks");
const run_trees_js_1 = require("./run_trees.cjs");
const env_js_1 = require("./utils/env.cjs");
function isPromiseMethod(x) {
    if (x === "then" || x === "catch" || x === "finally") {
        return true;
    }
    return false;
}
const asyncLocalStorage = new async_hooks_1.AsyncLocalStorage();
const isAsyncIterable = (x) => x != null &&
    typeof x === "object" &&
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof x[Symbol.asyncIterator] === "function";
const tracingIsEnabled = (tracingEnabled) => {
    if (tracingEnabled !== undefined) {
        return tracingEnabled;
    }
    const envVars = [
        "LANGSMITH_TRACING_V2",
        "LANGCHAIN_TRACING_V2",
        "LANGSMITH_TRACING",
        "LANGCHAIN_TRACING",
    ];
    return Boolean(envVars.find((envVar) => (0, env_js_1.getEnvironmentVariable)(envVar) === "true"));
};
const getTracingRunTree = (runTree, tracingEnabled) => {
    const tracingEnabled_ = tracingIsEnabled(tracingEnabled);
    if (!tracingEnabled_) {
        return undefined;
    }
    return runTree;
};
/**
 * Higher-order function that takes function as input and returns a
 * "TraceableFunction" - a wrapped version of the input that
 * automatically handles tracing. If the returned traceable function calls any
 * traceable functions, those are automatically traced as well.
 *
 * The returned TraceableFunction can accept a run tree or run tree config as
 * its first argument. If omitted, it will default to the caller's run tree,
 * or will be treated as a root run.
 *
 * @param wrappedFunc Targeted function to be traced
 * @param config Additional metadata such as name, tags or providing
 *     a custom LangSmith client instance
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function traceable(wrappedFunc, config) {
    const { aggregator, argsConfigPath, tracingEnabled, ...runTreeConfig } = config ?? {};
    const traceableFunc = (...args) => {
        let currentRunTree;
        let rawInputs;
        let ensuredConfig;
        try {
            let runtimeConfig;
            if (argsConfigPath) {
                const [index, path] = argsConfigPath;
                if (index === args.length - 1 && !path) {
                    runtimeConfig = args.pop();
                }
                else if (index <= args.length &&
                    typeof args[index] === "object" &&
                    args[index] !== null) {
                    if (path) {
                        const { [path]: extracted, ...rest } = args[index];
                        runtimeConfig = extracted;
                        args[index] = rest;
                    }
                    else {
                        runtimeConfig = args[index];
                        args.splice(index, 1);
                    }
                }
            }
            ensuredConfig = {
                name: wrappedFunc.name || "<lambda>",
                ...runTreeConfig,
                ...runtimeConfig,
                tags: [
                    ...new Set([
                        ...(runTreeConfig?.tags ?? []),
                        ...(runtimeConfig?.tags ?? []),
                    ]),
                ],
                metadata: {
                    ...runTreeConfig?.metadata,
                    ...runtimeConfig?.metadata,
                },
            };
        }
        catch (err) {
            console.warn(`Failed to extract runtime config from args for ${runTreeConfig?.name ?? wrappedFunc.name}`, err);
            ensuredConfig = {
                name: wrappedFunc.name || "<lambda>",
                ...runTreeConfig,
            };
        }
        const previousRunTree = asyncLocalStorage.getStore();
        if ((0, run_trees_js_1.isRunTree)(args[0])) {
            currentRunTree = args[0];
            rawInputs = args.slice(1);
        }
        else if ((0, run_trees_js_1.isRunnableConfigLike)(args[0])) {
            currentRunTree = run_trees_js_1.RunTree.fromRunnableConfig(args[0], ensuredConfig);
            rawInputs = args.slice(1);
        }
        else if (previousRunTree !== undefined) {
            currentRunTree = previousRunTree.createChild(ensuredConfig);
            rawInputs = args;
        }
        else {
            currentRunTree = new run_trees_js_1.RunTree(ensuredConfig);
            rawInputs = args;
        }
        currentRunTree = getTracingRunTree(currentRunTree, tracingEnabled);
        let inputs;
        const firstInput = rawInputs[0];
        if (firstInput == null) {
            inputs = {};
        }
        else if (rawInputs.length > 1) {
            inputs = { args: rawInputs };
        }
        else if (isKVMap(firstInput)) {
            inputs = firstInput;
        }
        else {
            inputs = { input: firstInput };
        }
        if (currentRunTree) {
            currentRunTree.inputs = inputs;
        }
        return asyncLocalStorage.run(currentRunTree, () => {
            const postRunPromise = currentRunTree?.postRun();
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            let returnValue;
            try {
                returnValue = wrappedFunc(...rawInputs);
            }
            catch (err) {
                returnValue = Promise.reject(err);
            }
            if (isAsyncIterable(returnValue)) {
                // eslint-disable-next-line no-inner-declarations
                async function* wrapOutputForTracing() {
                    let finished = false;
                    const chunks = [];
                    try {
                        for await (const chunk of returnValue) {
                            chunks.push(chunk);
                            yield chunk;
                        }
                        finished = true;
                    }
                    catch (e) {
                        await currentRunTree?.end(undefined, String(e));
                        throw e;
                    }
                    finally {
                        if (!finished) {
                            await currentRunTree?.end(undefined, "Cancelled");
                        }
                        let finalOutputs;
                        if (aggregator !== undefined) {
                            try {
                                finalOutputs = await aggregator(chunks);
                            }
                            catch (e) {
                                console.error(`[ERROR]: LangSmith aggregation failed: `, e);
                                finalOutputs = chunks;
                            }
                        }
                        else {
                            finalOutputs = chunks;
                        }
                        if (typeof finalOutputs === "object" &&
                            !Array.isArray(finalOutputs)) {
                            await currentRunTree?.end(finalOutputs);
                        }
                        else {
                            await currentRunTree?.end({ outputs: finalOutputs });
                        }
                        const onEnd = config?.on_end;
                        if (onEnd) {
                            if (!currentRunTree) {
                                console.warn("Can not call 'on_end' if currentRunTree is undefined");
                            }
                            else {
                                onEnd(currentRunTree);
                            }
                        }
                        await postRunPromise;
                        await currentRunTree?.patchRun();
                    }
                }
                return wrapOutputForTracing();
            }
            const tracedPromise = new Promise((resolve, reject) => {
                Promise.resolve(returnValue)
                    .then(
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                async (rawOutput) => {
                    if (isAsyncIterable(rawOutput)) {
                        // eslint-disable-next-line no-inner-declarations
                        async function* wrapOutputForTracing() {
                            let finished = false;
                            const chunks = [];
                            try {
                                // TypeScript thinks this is unsafe
                                for await (const chunk of rawOutput) {
                                    chunks.push(chunk);
                                    yield chunk;
                                }
                                finished = true;
                            }
                            catch (e) {
                                await currentRunTree?.end(undefined, String(e));
                                throw e;
                            }
                            finally {
                                if (!finished) {
                                    await currentRunTree?.end(undefined, "Cancelled");
                                }
                                let finalOutputs;
                                if (aggregator !== undefined) {
                                    try {
                                        finalOutputs = await aggregator(chunks);
                                    }
                                    catch (e) {
                                        console.error(`[ERROR]: LangSmith aggregation failed: `, e);
                                        finalOutputs = chunks;
                                    }
                                }
                                else {
                                    finalOutputs = chunks;
                                }
                                if (typeof finalOutputs === "object" &&
                                    !Array.isArray(finalOutputs)) {
                                    await currentRunTree?.end(finalOutputs);
                                }
                                else {
                                    await currentRunTree?.end({ outputs: finalOutputs });
                                }
                                const onEnd = config?.on_end;
                                if (onEnd) {
                                    if (!currentRunTree) {
                                        console.warn("Can not call 'on_end' if currentRunTree is undefined");
                                    }
                                    else {
                                        onEnd(currentRunTree);
                                    }
                                }
                                await postRunPromise;
                                await currentRunTree?.patchRun();
                            }
                        }
                        return resolve(wrapOutputForTracing());
                    }
                    else {
                        try {
                            await currentRunTree?.end(isKVMap(rawOutput) ? rawOutput : { outputs: rawOutput });
                            const onEnd = config?.on_end;
                            if (onEnd) {
                                if (!currentRunTree) {
                                    console.warn("Can not call 'on_end' if currentRunTree is undefined");
                                }
                                else {
                                    onEnd(currentRunTree);
                                }
                            }
                            await postRunPromise;
                            await currentRunTree?.patchRun();
                        }
                        finally {
                            // eslint-disable-next-line no-unsafe-finally
                            return rawOutput;
                        }
                    }
                }, 
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                async (error) => {
                    await currentRunTree?.end(undefined, String(error));
                    const onEnd = config?.on_end;
                    if (onEnd) {
                        if (!currentRunTree) {
                            console.warn("Can not call 'on_end' if currentRunTree is undefined");
                        }
                        else {
                            onEnd(currentRunTree);
                        }
                    }
                    await postRunPromise;
                    await currentRunTree?.patchRun();
                    throw error;
                })
                    .then(resolve, reject);
            });
            if (typeof returnValue !== "object" || returnValue === null) {
                return tracedPromise;
            }
            return new Proxy(returnValue, {
                get(target, prop, receiver) {
                    if (isPromiseMethod(prop)) {
                        return tracedPromise[prop].bind(tracedPromise);
                    }
                    return Reflect.get(target, prop, receiver);
                },
            });
        });
    };
    Object.defineProperty(traceableFunc, "langsmith:traceable", {
        value: runTreeConfig,
    });
    return traceableFunc;
}
exports.traceable = traceable;
/**
 * Return the current run tree from within a traceable-wrapped function.
 * Will throw an error if called outside of a traceable function.
 *
 * @returns The run tree for the given context.
 */
function getCurrentRunTree() {
    const runTree = asyncLocalStorage.getStore();
    if (runTree === undefined) {
        throw new Error([
            "Could not get the current run tree.",
            "",
            "Please make sure you are calling this method within a traceable function.",
        ].join("\n"));
    }
    return runTree;
}
exports.getCurrentRunTree = getCurrentRunTree;
function isTraceableFunction(x
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    return typeof x === "function" && "langsmith:traceable" in x;
}
exports.isTraceableFunction = isTraceableFunction;
function isKVMap(x) {
    return (typeof x === "object" &&
        x != null &&
        !Array.isArray(x) &&
        // eslint-disable-next-line no-instanceof/no-instanceof
        !(x instanceof Date));
}
function wrapFunctionAndEnsureTraceable(target, options, name = "target") {
    if (typeof target === "function") {
        return traceable(target, {
            ...options,
            name,
        });
    }
    throw new Error("Target must be runnable function");
}
exports.wrapFunctionAndEnsureTraceable = wrapFunctionAndEnsureTraceable;
