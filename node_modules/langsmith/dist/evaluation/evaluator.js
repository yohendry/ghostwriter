import { v4 as uuidv4 } from "uuid";
import { wrapFunctionAndEnsureTraceable } from "../traceable.js";
/**
 * Wraps an evaluator function + implements the RunEvaluator interface.
 */
export class DynamicRunEvaluator {
    constructor(evaluator) {
        Object.defineProperty(this, "func", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const wrappedFunc = (input) => {
            const runAndExample = input.langSmithRunAndExample;
            return evaluator(...Object.values(runAndExample));
        };
        this.func = wrappedFunc;
    }
    coerceEvaluationResults(results, sourceRunId) {
        if ("results" in results) {
            throw new Error("EvaluationResults not supported yet.");
        }
        return this.coerceEvaluationResult(results, sourceRunId, true);
    }
    coerceEvaluationResult(result, sourceRunId, allowNoKey = false) {
        if ("key" in result) {
            if (!result.sourceRunId) {
                result.sourceRunId = sourceRunId;
            }
            return result;
        }
        if (!("key" in result)) {
            if (allowNoKey) {
                result["key"] = this.func.name;
            }
        }
        return {
            sourceRunId,
            ...result,
        };
    }
    /**
     * Evaluates a run with an optional example and returns the evaluation result.
     * @param run The run to evaluate.
     * @param example The optional example to use for evaluation.
     * @returns A promise that extracts to the evaluation result.
     */
    async evaluateRun(run, example, options) {
        const sourceRunId = uuidv4();
        const metadata = {
            targetRunId: run.id,
        };
        if ("session_id" in run) {
            metadata["experiment"] = run.session_id;
        }
        const wrappedTraceableFunc = wrapFunctionAndEnsureTraceable(this.func, options || {}, "evaluator");
        // Pass data via `langSmithRunAndExample` key to avoid conflicts with other
        // inputs. This key is extracted in the wrapped function, with `run` and
        // `example` passed to evaluator function as arguments.
        const langSmithRunAndExample = {
            run,
            example,
        };
        const result = (await wrappedTraceableFunc({ langSmithRunAndExample }, {
            metadata,
        }));
        // Check the one required property of EvaluationResult since 'instanceof' is not possible
        if ("key" in result) {
            if (!result.sourceRunId) {
                result.sourceRunId = sourceRunId;
            }
            return result;
        }
        if (typeof result !== "object") {
            throw new Error("Evaluator function must return an object.");
        }
        return this.coerceEvaluationResults(result, sourceRunId);
    }
}
export function runEvaluator(func) {
    return new DynamicRunEvaluator(func);
}
